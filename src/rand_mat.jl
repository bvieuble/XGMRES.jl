# File: rand_mat.jl
# Author: Bastien Vieublé
# Email: bastien.vieuble@amss.ac.cn
# Github: https://github.com/bvieuble

""" 
```julia
A::Matrix{Float64} = gen_mat(
    n       ::Integer,              # Dimension of the matrix to generate 
    κₐ      ::Float64,              # Condition number of the matrix to \
                                      generate
    opt     ::String   = "default"  # If set to "reproductible", the same \
                                      Randome.seed!() is set and the same \
                                      sequence of matrices is generated \
                                      accross Julia sessions
)
```
Generate a random dense matrix with given condition number.
"""
function gen_mat(
        n    ::Integer,
        κₐ   ::Float64,
        opt  ::String    = "default"
    )

    if opt == "default"
        v = range(0, stop=-log10(κₐ), length=n)
        log = [10^i for i in v]
        D = Diagonal(log)
        Q, _ = qr(rand(n, n))
        A = transpose(Q) * D * Q
    elseif opt == "reproductible"
        v = range(0, stop=-log10(κₐ), length=n)
        log = [10^i for i in v]
        D = Diagonal(log)
        Random.seed!(1)
        Q, _ = qr(rand(n, n))
        A = transpose(Q) * D * Q
    end
    return A
end

""" 
```julia
A::Matrix{Float64}, M::Matrix{Float64} = gen_mat_with_prec(
    n    ::Integer,           # Dimension of the matrix A and M to generate
    κₐ   ::Float64,           # Condition number of the matrix A
    κₘ   ::Float64,           # Condition number of the preconditioner M
    opt  ::String="default"   # If set to "reproductible", the same \
                                Randome.seed!() is set and the same sequence \
                                of matrices is generated accross Julia sessions
)
``` 
Generate a random dense matrix A and an associated preconditioner M that 
satisfy 

\$\\kappa(M^{-1} A) = \\kappa(A M^{-1}) = \\kappa(A) / \\kappa(M).\$ 
"""
function gen_mat_with_prec(
        n   ::Integer,
        κₐ  ::Float64,
        κₘ  ::Float64,
        opt ::String="default"
    )

    if opt == "default"
        v = range(0, stop=-log10(κₐ), length=n)
        log = [10^i for i in v]
        D = Diagonal(log)
        Q, _ = qr(rand(n, n))
        A = transpose(Q) * D * Q
        D_trunc = Diagonal([max(D[i, i], inv(κₘ)) for i = 1:n])
        A = transpose(Q) * D * Q
        M = transpose(Q) * D_trunc * Q
    elseif opt == "reproductible"
        v = range(0, stop=-log10(κₐ), length=n)
        log = [10^i for i in v]
        D = Diagonal(log)
        Random.seed!(1)
        Q, _ = qr(rand(n, n))
        A = transpose(Q) * D * Q
        D_trunc = Diagonal([max(D[i, i], inv(κₘ)) for i = 1:n])
        A = transpose(Q) * D * Q
        M = transpose(Q) * D_trunc * Q
    elseif opt == "noise"
        v = range(0, stop=-log10(κₐ), length=n)
        log = [10^i for i in v]
        D = Diagonal(log)
        Q, _ = qr(rand(n, n))
        A = transpose(Q) * D * Q
        idx = findfirst(x -> x < inv(κₘ), log)
        if idx !== nothing
            D_trunc = ones(n)
            D_trunc[1:idx] = log[1:idx]
            D_trunc[idx+1:n] = rand(n - idx) * inv(κₘ)
        else
            D_trunc = log
        end
        D_trunc = Diagonal(D_trunc)
        A = transpose(Q) * D * Q
        M = transpose(Q) * D_trunc * Q
    end
    return A, M
end

"""
```julia
precond::Preconditioner = create_precond_rand(
    A   ::Matrix{TA},  # Matrix A 
    M   ::Matrix{TM},  # Preconditioner M of A
    uₐ  ::DataType,    # Precision at which the matrix A is applied
    uₘ  ::DataType     # Precision at which M^{-1} is applied
) where {TA<:AbstractFloat,TM<:AbstractFloat}
```
Generate the [`Preconditioner`](@ref) structure from random dense matrix A and 
its associated preconditioner M generated by [`gen_mat_with_prec`](@ref). The 
inverse of the preconditioner M is implicitely formed through computed exactly 
its LU factors and applying substitutions algorithms in precision ``u_a``.
"""
function create_precond_rand(
        A::Matrix{TA},
        M::Matrix{TM},
        uₐ::DataType,
        uₘ::DataType
    ) where {TA<:AbstractFloat,TM<:AbstractFloat}

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end
 
    Mₜ = xconvert(Float128, M)
    LUₜ = lu(Mₜ)

    if (eltype(LUₜ) != uₘ)
        LUₘ = xconvert(uₘ, LUₜ)
    else
        LUₘ = LUₜ
    end

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return LUₘ \ xconvert(uₘ, x), dict;
        # return LUₜ \ xconvert(Float128, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, LUₘ \ xconvert(uₘ, x))
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict();
        else
            dict = Dict();
        end
        dict["|Avⱼ|"]   = norm(Aₐ * xconvert(uₐ, x), 2)
        dict["|A||vⱼ|"] = norm(abs.(Aₐ) * abs.(x), 2)
        return LUₘ \ xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MAₑ = zeros(Float64, n, n)
        Aₑ  = xconvert(Float64, A)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            MAₑ[:, k] = LUₑ \ Aₑ[:, k]
        end
        return MAₑ
        # return Fq \ xconvert(Float128, A);
    end

    AM = function ()
        n   = size(A)[1]
        AMₑ = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        Aₑ  = xconvert(Float64, A)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            AMₑ[:, k] = LUₑ \ Iₑ[:, k]
        end
        AMₑ = Aₑ * AMₑ
        return AMₑ
        # return xconvert(Float128, A) / Fq;
    end

    M = function ()
        n   = size(A)[1]
        Mₑ  = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            Mₑ[:, k] = LUₑ \ Iₑ[:, k]
        end
        return Mₑ
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end
