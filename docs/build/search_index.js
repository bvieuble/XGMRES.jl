var documenterSearchIndex = {"docs":
[{"location":"auxiliary.html#Auxiliary-Functions","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"","category":"section"},{"location":"auxiliary.html","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"A set of additional functions that handle various subsidiary tasks, such as the conversion of various datatype in different floating point arithmetics or the generation of synthetic problems.","category":"page"},{"location":"auxiliary.html#Conversion-of-datatypes","page":"Auxiliary Functions","title":"Conversion of datatypes","text":"","category":"section"},{"location":"auxiliary.html","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"XGMRES.xconvert","category":"page"},{"location":"auxiliary.html#XGMRES.xconvert","page":"Auxiliary Functions","title":"XGMRES.xconvert","text":"a::u = xconvert(\n    u::DataType,  # Target floating point arith for the conversion\n    num::T        # Real number to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::Vector{u} = xconvert(\n    u::DataType,    # Target floating point arith for the conversion\n    vec::Vector{T}  # Vector of real to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::Matrix{u} = xconvert(\n    u::DataType,    # Target floating point arith for the conversion\n    mat::Matrix{T}  # Matrix of real to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::IncompleteLU.ILUFactorization{u,Int64}) = xconvert(\n    u::DataType,                                 # Target floating point arith for the conversion\n    mat::IncompleteLU.ILUFactorization{T,Int64}  # IncompleteLU factors structure to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::LU{u,Matrix{u},Vector{Int64}}) = xconvert(\n    u::DataType,                         # Target floating point arith for the conversion\n    fact::LU{T,Matrix{T},Vector{Int64}}  # LinearAlgebra.LU factors structure to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::Symmetric{u,SparseMatrixCSC{u,Int64}} = xconvert(\n    u::DataType,                                # Target floating point arith for the conversion\n    mat::Symmetric{T,SparseMatrixCSC{T,Int64}}  # Symmetric sparse matrix to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::SparseMatrixCSC{u,Ti} = xconvert(\n    u::DataType,                 # Target floating point arith for the conversion\n    mat::SparseMatrixCSC{Tv,Ti}  # Sparse matrix to convert\n) where {Tv<:AbstractFloat,Ti<:Integer}\n\n\n\n\n\na::Adjoint{u,SparseMatrixCSC{u,Int64}} = xconvert(\n    u::DataType,                              # Target floating point arith for the conversion\n    mat::Adjoint{T,SparseMatrixCSC{T,Int64}}  # Adjoint sparse matrix to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::Vector{Vector{u}} = xconvert(\n    u::DataType,            # Target floating point arith for the conversion\n    vec::Vector{Vector{T}}  # Vector of vector of real to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\na::AlgebraicMultigrid.MultiLevel{\n        AlgebraicMultigrid.Pinv{u},\n        GaussSeidel{SymmetricSweep},\n        GaussSeidel{SymmetricSweep},\n        SparseMatrixCSC{u,Int64}, \n        Adjoint{u,SparseMatrixCSC{u,Int64}},\n        SparseMatrixCSC{u,Int64}, \n        AlgebraicMultigrid.MultiLevelWorkspace{Vector{u},1}\n} = xconvert(\n    u::DataType,  # Target floating point arith for the conversion\n    mat::AlgebraicMultigrid.MultiLevel{         # AlgebraicMultigrid datatype\n                AlgebraicMultigrid.Pinv{T},     # to convert\n                GaussSeidel{SymmetricSweep},\n                GaussSeidel{SymmetricSweep},\n                SparseMatrixCSC{T,Int64}, \n                Adjoint{T,SparseMatrixCSC{T,Int64}},\n                SparseMatrixCSC{T,Int64}, \n                AlgebraicMultigrid.MultiLevelWorkspace{Vector{T},1}}\n) where {T<:AbstractFloat}\n\n\n\n\n\na::ILUZero.ILU0Precon{u,Int64,u}) = xconvert(\n    u::DataType,                        # Target floating point arith for the conversion\n    mat::ILUZero.ILU0Precon{T,Int64,T}  # IncompleteLU factors structure to convert\n) where {T<:AbstractFloat}\n\n\n\n\n\n𝑃::Poly = xconvert(\n    u::DataType,       # Target floating point arith for the conversion\n    poly::Poly{TA,TP}  # Polynomial to convert\n) where {TA<:AbstractFloat,TP<:AbstractFloat}\n\n\n\n\n\n","category":"function"},{"location":"auxiliary.html#Random-dense-problems-generator","page":"Auxiliary Functions","title":"Random dense problems generator","text":"","category":"section"},{"location":"auxiliary.html","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"XGMRES.gen_mat\nXGMRES.gen_mat_with_prec","category":"page"},{"location":"auxiliary.html#XGMRES.gen_mat","page":"Auxiliary Functions","title":"XGMRES.gen_mat","text":"A::Matrix{Float64} = gen_mat(\n    n       ::Integer,              # Dimension of the matrix to generate \n    κₐ      ::Float64,              # Condition number of the matrix to generate\n    opt     ::String   = \"default\"  # If set to \"reproductible\", the same Randome.seed!() is set and the same sequence of matrices is generated accross Julia sessions\n)\n\nGenerate a random dense matrix with given condition number.\n\n\n\n\n\n","category":"function"},{"location":"auxiliary.html#XGMRES.gen_mat_with_prec","page":"Auxiliary Functions","title":"XGMRES.gen_mat_with_prec","text":"A::Matrix{Float64}, M::Matrix{Float64} = gen_mat_with_prec(\n    n    ::Integer,           # Dimension of the matrix A and M to generate\n    κₐ   ::Float64,           # Condition number of the matrix A\n    κₘ   ::Float64,           # Condition number of the preconditioner M\n    opt  ::String=\"default\"   # If set to \"reproductible\", the same Randome.seed!() is set and the same sequence of matrices is generated accross Julia sessions\n)\n\nGenerate a random dense matrix A and an associated preconditioner M that  satisfy \n\nkappa(M^-1 A) = kappa(A M^-1) = kappa(A)  kappa(M)\n\n\n\n\n\n","category":"function"},{"location":"xgmres.html#XGMRES","page":"XGMRES","title":"XGMRES","text":"","category":"section"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"The xgmres solver, combined with a given preconditioner, can make use of up to six different floating point arithmetics. For the sake of readability, we use the following set of consistent notations to identify easily the precision at which a given variable is stored and an operation is performed. These notations are consistent accross this  documentation and the source code. You can find below a table listing the different operations, their associated floating point datatype, and the  subscript used for this floating point datatype.","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"Operations Floating point datatype Subscript\nResidual Ax_i+1 - b u_r r\nUpdate x_i+1 = x_i + d_i u no subscript\nPreconditioner computation u_x x\nPreconditioner application Mtimes v u_m m\nMatrix application Atimes v u_a a\nRest of the GMRES operations u_s s","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"For instance, if a variable is noted varₓ, this variable is stored in precision u_x and is likely associated to the preconditioner computation.","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"The floating point arithmetic u is also refered to as the working precision. This is the arithmetic at which the solution x of  xgmres is delivered. We also use this notation when  it is not pertinent to make a distinction between different floating point arithmetics. Similarly, we do not add subscript to a variable in those cases.","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"Finally, in some parts of the code we refer to variables explicitly stored in  Float64 or Float128 (through the  Quadmath package). For those cases we use the following subscripts.","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"Floating point datatype Subscript\nFloat64 e\nFloar128 t","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"Note that we would have liked subscripts d and q, respectively for Float64 (double precision) and Float128 (quadruple precision), but Julia's unicode does not have these options.","category":"page"},{"location":"xgmres.html","page":"XGMRES","title":"XGMRES","text":"XGMRES.xgmres","category":"page"},{"location":"xgmres.html#XGMRES.xgmres","page":"XGMRES","title":"XGMRES.xgmres","text":"x::Vector{u}, stats::Dict = xgmres(\n    A         ::AbstractMatrix{TA},                  \n    b         ::AbstractVector{TB};                  \n    precond   ::Preconditioner            = nothing, \n    kind      ::String                    = \"left\",  \n    xexact    ::Union{Vector{TX},Nothing} = nothing, \n    maxrestrt ::Union{Integer,   Nothing} = nothing, \n    m         ::Union{Integer,   Nothing} = nothing, \n    τ         ::Union{Float64,   Nothing} = nothing, \n    bstop     ::Union{Float64,   Nothing} = nothing, \n    fstop     ::Union{Float64,   Nothing} = nothing, \n    stop      ::Union{Float64,   Nothing} = nothing, \n    verbose   ::Bool                      = true,    \n    do_stats  ::Bool                      = false,   \n    do_κ      ::Bool                      = false,   \n    u         ::DataType                  = Float64, \n    uᵣ        ::DataType                  = Float64, \n    uₛ        ::DataType                  = Float64, \n    maxmem    ::Float64                   = 3*1e9    \n) where {TA<:AbstractFloat,TB<:AbstractFloat,TX<:AbstractFloat}\n\nSolve the linear system Ax=b with mixed precision restarted preconditioned  GMRES, where AinmathbbR^ntimes n and xb inmathbbR^n. The function requires three precision parameters and repeats the three  following steps until convergence:\n\nCompute the residual r_i = b-Ax_i in precision u_r\nSolve A d_i = r_ir_i_infty with preconditioned GMRES run in  precision u_s\nUpdate the solution x_i+1 = x_i + r_i_inftytimes d_i in  precision u\n\nThe precisions u_r and u  concern, respectively, the precisions at  which the residual (step 1) and the update of the solution (step 3) are  computed. The precision u_s is the precision at which all the operations of the inner GMRES, except the preconditioned matrix-vector product, are computed (step 2). The preconditioned matrix-vector product should be provided through  the precond parameter.\n\nnote: Preconditioned matrix-vector product\nThe preconditioned matrix-vector product can use its own set of precisions  and does not have to be implemented in precision uₛ. One should use  the Preconditioner structure provided by the package to implement it or  use provided implementations by the package. \n\nThe algorithm is composed of two imbricated loops: the outer restart loop and  the inner GMRES iterations. The restart loop is stopped if:\n\nWe reached the maximum number of restart iterations maxrestrt.\nWe observe no significant error reduction over three consecutives  iterations. This is quantified by the parameter stop which defines the maximum acceptable ratio between  the forward errors of two consecutive iterations. \nWe reached the expected accuracies on the forward and backward errors  defined by the parameters fstop and bstop.\n\nIf the parameter xexact is not provided, the forward error is not computed,  and the above stopping criterion are solely based on the computed backward  error. The backward and forward error of the linear system are computed,  respectively, as follows:\n\nfracAx_i-b_inftyA_inftyx_i_infty + \nb_infty\n\nfracx_i - x_inftyx_infty\n\nThe inner GMRES loop is stopped if:\n\nWe reached the maximum number of GMRES iterations m.\nThe backward error of the preconditioned system Ad_i=r_i falls below a  given tolerance defined by the paramter τ.\n\nThe backward error of the preconditioned system is computed as follows:\n\nfracM^-1(Ad_ij - r_ir_i_infty)_inftyM^-1r_i\nr_i_infty_infty qquad text(left-preconditioned)\n\nfracAd_ij - r_ir_i_infty)_inftyr_i\nr_i_infty_infty qquad text(right-preconditioned)\n\nnote: Right-preconditioned backward error\nThe backward error of the right-preconditioned system is the backward error of the original system A d_i = r_ir_i_infty.\n\nThrough the parameter do_stats, it can be asked to the function to compute  the backward errors of the original system Ax=b for each iteration of GMRES.  The forward errors are also computed if the exact solution of the system is  provided through the parameter xexact. The condition numbers of the  preconditioner and the preconditioned matrix can also be computed through  another parameter do_κ. It lets the possibility to compute the do_stats  advanced errors on systems where the condition number is too expensive or  impossible to compute.\n\nwarning: Stats mode\nThe stat mode increases substantially the resource comsumption and is only  relevant for numerical study of the algorithm. It is not intended to be  used in practice.\n\nInput arguments\n\nA: A square general matrix AinmathbbR^ntimes n\nb: A right-hand side binmathbbR^n\n\nKeyword arguments\n\nprecond: A Preconditioner object embedding the linear operators  used for preconditioning\nkind: Set the kind of preconditioning (\"left\", \"right\", or \"flexible\")\nxexact: Exact solution of the system. If provided the forward error is  computed in stat mode.\nmaxrestrt: Maximum number of restart iterations.\nm: Maxmum number of inner GMRES iterations.\nτ: Stopping criterion for the inner iterations of GMRES based on the  backward error of the correction system A d_i = r_ir_i_infty.\nbstop: Stopping criterion for the outer restart iterations based on the  backward error of the original system A x_i = b.\nfstop: Stopping criterion for the outer restart iterations based on the  forward error of the original system.\nstop: Stopping criterion for the outer restart iterations based on the  based on the non-improvement of the forward error over 3 iterations. If the forward error is not improved by a ratio higher than stop for three  consecutive restart iterations, the algorithm is stopped.\nverbose: Information and convergence logs are displayed at each iteration.\ndo_stats: Activate the stats mode and get many more logs.\ndo_κ: Compute the condition numbers of the preconditioner M and the preconditioned matrix AM or MA (depending on the kind of  preconditioning used).\nu: Precision at which the update x_i+1 = x_i + d_i is computed.\nuᵣ: Precision at which the residual Ax_i+1 - b is computed.\nuₛ: Precision at which the operations in the inner loop of GMRES are  computed.\nmaxmem: Use to set m if m is not provided in argument. It chooses m such that the memory used to store the Krylov bases is lower than maxmem.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"The package wraps and implements various preconditioners. The complete list is given below:","category":"page"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"Preconditioners Method Dense Sparse\nIdentity create_precond_I ✓ ✓\nLU create_precond_lu ✓ \nILU create_precond_ilu  ✓\nAMG create_precond_amg  ✓\nPolynomial create_precond_poly ✓ ✓\nSPAI create_precond_spai  ✓\nRandom[1] create_precond_rand ✓ ","category":"page"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"[1]: Only useable when the problems are generated with    gen_mat_with_prec.","category":"page"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"To have a consistent interface to be used inside xgmres, the  preconditioners are wrapped in the following structure. ","category":"page"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"XGMRES.Preconditioner","category":"page"},{"location":"preconditioners.html#XGMRES.Preconditioner","page":"Preconditioners","title":"XGMRES.Preconditioner","text":"struct Preconditioner\n    Mx  ::Function   # Function forming M * vector\n    AMx ::Function   # Function forming A * M * vector\n    MAx ::Function   # Function forming M * A * vector\n    MA  ::Function   # Function computing M * A (useful in do_stats mode)\n    AM  ::Function   # Function computing A * M (useful in do_stats mode)\n    M   ::Function   # Function forming explicitely M^(-1) (useful in do_stats # mode)\nend\n\nA structure that describes the preconditioner interface of this package. Each  preconditioner has to be wrapped in this structure to be used by  xgmres. In particular, the Preconditioner.Mx function  implements the application of the preconditioner to a vector. The  Preconditioner.AMx implements the right-preconditioned product A times M times v  used when xgmres is set in right-preconditioning mode  (kind=\"right\"). Conversely, the Preconditioner.MAx implements the  left-preconditioned product M times A times v used when xgmres is set in left-preconditioning mode (kind=\"left\").\n\n\n\n\n\n","category":"type"},{"location":"preconditioners.html#List-of-available-preconditioners","page":"Preconditioners","title":"List of available preconditioners","text":"","category":"section"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"XGMRES.create_precond_I\nXGMRES.create_precond_lu\nXGMRES.create_precond_ilu\nXGMRES.create_precond_amg\nXGMRES.create_precond_poly\nXGMRES.create_precond_spai\nXGMRES.create_precond_rand","category":"page"},{"location":"preconditioners.html#XGMRES.create_precond_I","page":"Preconditioners","title":"XGMRES.create_precond_I","text":"precond::Preconditioner = create_precond_I(\n    A  ::AbstractMatrix{T},  # Matrix A \n    uₐ ::DataType            # Precision at which the matrix A is applied\n) where {T<:AbstractFloat}\n\nIdentity preconditioner. It allows to run the mixed precision GMRES algorithm  xgmres without preconditioners.\n\nnote: Use case\nThe function xgmres requires a precond parameter. When this  parameter is not provided, the function intializes precond as an  identity preconditioner generated by this function.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_lu","page":"Preconditioners","title":"XGMRES.create_precond_lu","text":"precond::Preconditioner = create_precond_lu(\n    A   ::AbstractMatrix{T},  # Matrix A\n    uₓ  ::DataType,           # Precision at which the LU factorization is computed\n    uₐ  ::DataType,           # Precision at which the matrix A is applied\n    uₘ  ::DataType            # Precision at which M^{-1} is applied\n) where {T<:AbstractFloat}\n\nLU preconditioner using the builtin Julia LU factorization  LinearAlgebra.lu.\n\nwarning: Sparse matrices not allowed\nThe sparse Julia LU factorization calls UMFPACK, which only supports Float64 arithmetic. For this reason we densify the matrix when using this  preconditioner when the input is sparse.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_ilu","page":"Preconditioners","title":"XGMRES.create_precond_ilu","text":"precond::Preconditioner = create_precond_ilu(\n    A  ::AbstractSparseMatrix{Tv,Ti},  # Matrix A\n    τ  ::Float64,  # Parameter of ILU quantifying the accuracy of the incomplete factorization\n    uₓ ::DataType, # Precision at which the ILU factorization is computed\n    uₐ ::DataType, # Precision at which the matrix A is applied\n    uₘ ::DataType  # Precision at which M^{-1} is applied\n) where {Tv<:AbstractFloat,Ti<:Integer}\n\nThreshold incomplete LU preconditioner. It is a wrapper of the  IncompleteLU.jl package. \n\nwarning: Symmetric matrices not allowed\nThe ILU preconditioner cannot be applied on Julia sparse symmetric  matrices. The underlying reason being that there are better preconditioners dedicated to the symmetric case (e.g., Incomplete Cholesky). However, as  the symmetric equivalent of the threshold ILU package we use does not  exist, for convernience, we also use the ILU preconditioner on symmetric  problems by unsymmetrizing the input matrix.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_amg","page":"Preconditioners","title":"XGMRES.create_precond_amg","text":"precond::Preconditioner = create_precond_amg(\n    A  ::AbstractSparseMatrix{Tv,Ti}, # Matrix A\n    uₓ ::DataType,  # Precision at which the AMG preconditioner is computed\n    uₐ ::DataType,  # Precision at which the matrix A is applied\n    uₘ ::DataType   # Precision at which the AMG preconditioner is applied\n) where {Tv<:AbstractFloat,Ti<:Integer}\n\nAlgebraic Multigrid preconditioner. It is a wrapper of the  AlgebraicMutligrid.jl package.\n\nnote: Sparse only\nBy construction the AMG preconditioner can only be applied to sparse  matrices.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_poly","page":"Preconditioners","title":"XGMRES.create_precond_poly","text":"precond::Preconditioner = create_precond_poly(\n    A   ::AbstractMatrix{TA},  # Matrix A\n    b   ::Vector{TB},  # Right-hand side b\n    uₓ  ::DataType,    # Precision at which the polynomial preconditioner is computed\n    uₐ  ::DataType,    # Precision at which the matrix A is applied\n    uₘ  ::DataType;    # Precision at which the polynomial preconditioner is applied\n    deg ::Integer = 20 # Degree of the polynomial to generate\n) where {TA<:AbstractFloat,TB<:AbstractFloat}\n\nPolynomial preconditioner based on Arnoldi iterations calling the function  polynomial provided in this package.\n\nnote: Right-hand side\nTo initialize the polynomial preconditioner, the right-hand side of  the system needs to be provided.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_spai","page":"Preconditioners","title":"XGMRES.create_precond_spai","text":"precond::Preconditioner = create_precond_spai(\n    A     ::Union{AbstractSparseMatrix{Tv,Ti},\n                  Symmetric{Tv,SparseMatrixCSC{T,Ti}}}, # Matrix A\n    uₓ    ::DataType,          # Precision at which the SPAI preconditioner is computed\n    uₐ    ::DataType,          # Precision at which the matrix A is applied\n    uₘ    ::DataType;          # Precision at which M^{-1} is applied\n    kind  ::String  = \"left\",  # Kind of preconditioning: 'left', 'right', or 'flexible'\n    ϵ     ::Float64 = 0.3,     # Accuracy of the approximation\n    β     ::Integer = 8,       # Maximum number of nnz to add in a column after one refinement\n    α     ::Integer = round(Int64, size(A)[1] / β, RoundUp)  # Maximum number of time we refine a column\n) where {Tv<:AbstractFloat,Ti<:Integer}\n\nSparse approximate inverse preconditioner calling the function spai  provided in this package.\n\nwarning: Sparse with full diagonal only\nThe SPAI preconditioner can only be applied to sparse systems. For now, the initial sparsity pattern of the SPAI preconditioner implemented in this  package is set to be the identity. Therefore, any matrix with zeroes on the diagonal can fail.\n\nnote: Left and right preconditioner\nDepending on if left or right preconditioning is used, the preconditioner itself is not computed in the same way.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#XGMRES.create_precond_rand","page":"Preconditioners","title":"XGMRES.create_precond_rand","text":"precond::Preconditioner = create_precond_rand(\n    A   ::Matrix{TA},  # Matrix A \n    M   ::Matrix{TM},  # Preconditioner M of A\n    uₐ  ::DataType,    # Precision at which the matrix A is applied\n    uₘ  ::DataType     # Precision at which M^{-1} is applied\n) where {TA<:AbstractFloat,TM<:AbstractFloat}\n\nGenerate the Preconditioner structure from random dense matrix A and  its associated preconditioner M generated by gen_mat_with_prec. The  inverse of the preconditioner M is implicitely formed through computed exactly  its LU factors and applying substitutions algorithms in precision u_a.\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#Sparse-approximate-inverse","page":"Preconditioners","title":"Sparse approximate inverse","text":"","category":"section"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"XGMRES.spai","category":"page"},{"location":"preconditioners.html#XGMRES.spai","page":"Preconditioners","title":"XGMRES.spai","text":"M::SparseMatrixCSC{Tv,Ti} = spai(\n    A ::Union{SparseMatrixCSC{Tv,Ti},Adjoint{Tv,SparseMatrixCSC{Tv,Ti}}},  # Sparse matrix A we compute the SPAI of \n    ϵ ::Float64,  # Accuracy of the approximation\n    α ::Integer,  # Maximum number of time we refine a column \n    β ::Integer   # Maximum number of nnz to add in a column after one refinement\n) where {Tv<:AbstractFloat,Ti<:Integer} \n\nComputation of Sparse Approximate Inverse preconditioner (SPAI) of a given  sparse matrix A. This implementation is a Julia rewrite of the Matlab code of this  github repo, which is itself the companion code of the article \"Mixed Precision Iterative Refinement with Sparse Approximate Inverse Preconditioning\"[2].\n\n[2]: Erin Carson & Noaman Khan, \"Mixed Precision Iterative Refinement with    Sparse Approximate Inverse Preconditioning\", SIAM Journal on Scientific    Computing, (2023).\n\nIn more detail, the function implement the following algorithm from[2]. Note  however that, in our implementation, the initial sparsity pattern  mathcalJ is set to be always the identity.\n\n(Image: spai_img)\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#Polynomial-preconditioner","page":"Preconditioners","title":"Polynomial preconditioner","text":"","category":"section"},{"location":"preconditioners.html","page":"Preconditioners","title":"Preconditioners","text":"XGMRES.Poly\nXGMRES.polynomial\nBase.:*","category":"page"},{"location":"preconditioners.html#XGMRES.Poly","page":"Preconditioners","title":"XGMRES.Poly","text":"struct Poly{TA<:AbstractFloat,TP<:AbstractFloat}\n    A    ::AbstractMatrix{TA}  # The matrix A \n    H    ::Matrix{TP}  # The Arnoldi Hessenberg matrix \n    g    ::Vector{TP}  # Coefficients of the poly in the Arnoldi basis\n    deg  ::Integer     # Degree of the polynomial\nend\n\nA structure that describes the Arnoldi-based polynomial preconditioner.  Computing such a polynomial from a matrix A, a right-hand side b, and  a given degree can be done with the method polynomial. The  application of the polynomial to a vector is available through  Base.:*.\n\n\n\n\n\n","category":"type"},{"location":"preconditioners.html#XGMRES.polynomial","page":"Preconditioners","title":"XGMRES.polynomial","text":"𝑃::Poly = polynomial(\n    A    ::AbstractMatrix{TA},\n    b    ::AbstractVector{TB},\n    deg  ::Integer\n) where {TA<:AbstractFloat,TB<:AbstractFloat}\n\nComputation of an Arnoldi-based polynomial preconditioner for the matrix A. The floating point arithmetic u at which the computation is performed is the  arithmetic of the elements of A; if b is not provided in this arithmetic,  it is casted in precision uₓ. This implementation is based on the pseudo-code  proposed in the article \"Polynomial Preconditioned GMRES and GMRES-DR\"[3].\n\n(Image: poly_img)\n\n[3]: Quan Liu, Ronald B. Morgan, and Walter Wilcox, \"Polynomial    Preconditioned GMRES and GMRES-DR\", SIAM Journal on Scientific    Computing, (2015).\n\n\n\n\n\n","category":"function"},{"location":"preconditioners.html#Base.:*","page":"Preconditioners","title":"Base.:*","text":"y::AbstractVector = (*)(\n    𝑃   ::Poly{TP},           # Polynomial\n    v   ::AbstractVector{TV}  # Vector\n) where {TP<:AbstractFloat,TM<:AbstractFloat,TV<:AbstractFloat}\n\nApplication of an Arnoldi-based polynomial to a vector p(A) times v.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Overview","title":"Overview","text":"CurrentModule = XGMRES","category":"page"},{"location":"index.html#Mixed-precision-preconditioning-strategies-for-GMRES","page":"Overview","title":"Mixed precision preconditioning strategies for GMRES","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"This Julia package provides a mixed precision GMRES implementation with its set of preconditioners for the solution of square general linear systems. It is the companion code of the academic article \"Mixed precision preconditioning  strategies for GMRES\".","category":"page"},{"location":"index.html#Index","page":"Overview","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Pages = [\"xgmres.md\",\"preconditioners.md\",\"auxiliary.md\"]","category":"page"},{"location":"index.html#How-to-use","page":"Overview","title":"How to use","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Using xgmres can be as simple as writing","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"A = rand(100,100)\nb = rand(100)\nx = xgmres(A,b)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"To go further, other parameters are fine-tuneable, including the  precisions at which the operations are performed. The complete list of the  parameters is provided in the function doc xgmres.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"The scripts/dense.jl and scripts/sparse.jl files in this repo are good examples of applications of the function. The first script runs xgmres on a random dense synthetic problem generated with target condition numbers for A  and for the preconditioner. The second script loads a SuiteSparse matrix and  runs xgmres on this problem with one of our built-in preconditioner.  These files can also be used to reproduce or check the results presented in (most of)  the plots of the article. ","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"These scripts can be conveniently run in the background with  the Bash commands","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"sh ./scripts/scripts.sh dense.jl\nsh ./scripts/scripts.sh sparse.jl","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"or launch directly with Julia from the root of the project","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"julia --project=. scripts/sparse.jl\njulia --project=. scripts/sparse.jl","category":"page"},{"location":"index.html#Disclaimers","page":"Overview","title":"Disclaimers","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"The sole purpose of the XGMRES.jl GitHub repo is to provide the Julia scripts used to generate the numerical results of the academic paper \"Mixed precision preconditioning strategies for GMRES\". This code WON'T BE  MAINTAINED and won't be made available through the Julia package repository. Hence, we advise people looking for a reliable, standard, and performant Julia  implementation of GMRES to use the more mature  Krylov.jl library.","category":"page"},{"location":"index.html#Acknowledgements","page":"Overview","title":"Acknowledgements","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"We would like to acknowledge various repositories that helped us build this work:","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"IncompleteLU.jl\nSPAI-GMRES-IR\nBFloat16s\nQuadmath.jl\nMatrixMarket.jl\nSuiteSparseMatrixCollection.jl","category":"page"}]
}
